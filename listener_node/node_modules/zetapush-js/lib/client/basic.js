'use strict';

exports.__esModule = true;
exports.Client = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _helper = require('./helper');

var _index = require('../utils/index');

var _connectionStatus = require('../connection/connection-status');

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Client config object.
 * @typedef {Object} ClientConfig
 * @property {string} apiUrl - Api Url
 * @property {string} sandboxId - Sandbox id
 * @property {boolean} forceHttps - Force end to end HTTPS connection
 * @property {function():AbstractHandshake} authentication - Return authentication properties
 * @property {string} resource - Client resource id
 * @property {Transports} transports - Client transports implementation
 */

/**
 * ZetaPush Client to connect
 * @access public
 * @example
 * // Securized client with token based connection
 * const client = new ZetaPush.Client({
 *   sandboxId: '<YOUR-SANDBOX-ID>',
 *   authentication() {
 *     return ZetaPush.Authentication.weak({
 *       token: null
 *    })
 *   }
 * })
 * @example
 * // Client with authentication based connection
 * const client = new ZetaPush.Client({
 *   sandboxId: '<YOUR-SANDBOX-ID>',
 *   authentication() {
 *     return ZetaPush.Authentication.simple({
 *       login: '<USER-LOGIN>',
 *       password: '<USER-PASSWORD>'
 *    })
 *   }
 * })
 * @example
 * // Explicit deploymentId
 * const clientSimple = new ZetaPush.Client({
 *   sandboxId: '<YOUR-SANDBOX-ID>',
 *   authentication() {
 *     return ZetaPush.Authentication.simple({
 *       deploymentId: '<YOUR-SIMPLE-AUTHENTICATION-DEPLOYMENT-ID>',
 *       login: '<USER-LOGIN>',
 *       password: '<USER-PASSWORD>'
 *    })
 *   }
 * })
 * const clientWeak = new ZetaPush.Client({
 *   sandboxId: '<YOUR-SANDBOX-ID>',
 *   authentication() {
 *     return ZetaPush.Authentication.weak({
 *       deploymentId: '<YOUR-WEAK-AUTHENTICATION-DEPLOYMENT-ID>',
 *       token: '<SESSION-TOKEN>'
 *    })
 *   }
 * })
 */
var Client = exports.Client = function () {
  /**
   * Create a new ZetaPush Client
   * @param {ClientConfig} config
   */
  function Client(_ref) {
    var _ref$apiUrl = _ref.apiUrl,
        apiUrl = _ref$apiUrl === undefined ? _index.API_URL : _ref$apiUrl,
        sandboxId = _ref.sandboxId,
        _ref$forceHttps = _ref.forceHttps,
        forceHttps = _ref$forceHttps === undefined ? _index.FORCE_HTTPS : _ref$forceHttps,
        authentication = _ref.authentication,
        resource = _ref.resource,
        transports = _ref.transports;

    _classCallCheck(this, Client);

    /**
     * @access private
     * @type {ClientHelper}
     */
    this.helper = new _helper.ClientHelper({
      apiUrl: apiUrl,
      sandboxId: sandboxId,
      forceHttps: forceHttps,
      authentication: authentication,
      resource: resource,
      transports: transports
    });
  }
  /**
   * Add a connection listener to handle life cycle connection events
   * @param {ConnectionStatusListener} listener
   * @return {number} handler
   */


  _createClass(Client, [{
    key: 'addConnectionStatusListener',
    value: function addConnectionStatusListener(listener) {
      return this.helper.addConnectionStatusListener(listener);
    }
    /**
     * Safely connect client to ZetaPush
     */

  }, {
    key: 'connect',
    value: function connect() {
      var _this = this;

      if (this.isConnected()) {
        var handler = this.addConnectionStatusListener({
          onConnectionClosed: function onConnectionClosed() {
            _this.removeConnectionStatusListener(handler);
            _this.helper.connect();
          }
        });
        this.disconnect();
      } else {
        this.helper.connect();
      }
    }
    /**
     * Create a promise based service instance
     * @param {{listener: Object, Type: class, deploymentId: string}} parameters
     * @return {Object} service
     * @example
     * const api = client.createAsyncMacroService({
     *   Type: WelcomeMacro
     * })
     * api.welcome({
     *   message: Hello'
     * }).then(({ message }) => {
     *   console.log(message)
     * })
     */

  }, {
    key: 'createAsyncMacroService',
    value: function createAsyncMacroService(_ref2) {
      var deploymentId = _ref2.deploymentId,
          listener = _ref2.listener,
          Type = _ref2.Type;

      return this.helper.createAsyncMacroService({ deploymentId: deploymentId, listener: listener, Type: Type });
    }
    /**
     * Create a publish/subscribe for a service type
     * @param {{listener: Object, Type: class, deploymentId: string}} parameters
     * @return {Object} service
     * @example
     * const service = client.createService({
     *   listener: {
     *     list(message) {
     *       console.log('Stack list callback', message)
     *     },
     *     push(message) {
     *       console.log('Stack push callback', message)
     *     }
     *   },
     *   Type: ZetaPush.services.Stack
     * })
     * service.list({
     *   stack: '<STACK-ID>'
     * })
     * @example
     * // Explicit deploymentId
     * // Authentication provide optional deployment id, according to the following convention `${ServiceType.toLowerCase()_0}`
     * const service = client.createService({
     *   deploymentId: 'stack_0'
     *   listener: {
     *     list(message) {
     *       console.log('Stack list callback', message)
     *     },
     *     push(message) {
     *       console.log('Stack push callback', message)
     *     }
     *   },
     *   Type: ZetaPush.services.Stack
     * })
     * service.list({
     *   stack: '<STACK-ID>'
     * })
     */

  }, {
    key: 'createService',
    value: function createService(_ref3) {
      var deploymentId = _ref3.deploymentId,
          listener = _ref3.listener,
          Type = _ref3.Type;

      return this.helper.createService({ deploymentId: deploymentId, listener: listener, Type: Type });
    }
    /**
     * Disonnect client from ZetaPush
     */

  }, {
    key: 'disconnect',
    value: function disconnect() {
      if (this.isConnected()) {
        this.helper.disconnect();
      }
    }
    /**
     * Is client connected to ZetaPush
     * @return {boolean}
     */

  }, {
    key: 'isConnected',
    value: function isConnected() {
      return this.helper.isConnected();
    }
    /**
     * Get the client sandbox id
     * @return {string}
     */

  }, {
    key: 'getSandboxId',
    value: function getSandboxId() {
      return this.helper.getSandboxId();
    }
    /**
     * Get the client resource
     * @return {string}
     */

  }, {
    key: 'getResource',
    value: function getResource() {
      return this.helper.getResource();
    }
    /**
     * Get server urls list
     * @return {Promise} servers
     */

  }, {
    key: 'getServers',
    value: function getServers() {
      return this.helper.getServers();
    }
    /**
     * Get the client user id
     * @return {string}
     */

  }, {
    key: 'getUserId',
    value: function getUserId() {
      return this.helper.getUserId();
    }
    /*
     * Get the client user info
     * @return {Object}
     * @example
     * // Create new ZetaPush Client
     * const client = new Client({
     *   sandboxId: '<YOUR-SANDBOX-ID>',
     *   authentication: () => Authentication.simple({
     *     login: '<YOUR-USER-LOGIN>',
     *     password: '<YOUR-USER-PASSWORD>'
     *   })
     * })
     * // Add connection establised listener
     * client.onConnectionEstablished(() => {
     *   console.log('onConnectionEstablished')
     *   const profile = client.getUserInfo()
     *   console.log('Your profile', profile)
     * })
     * client.connect()
     */

  }, {
    key: 'getUserInfo',
    value: function getUserInfo() {
      return this.helper.getUserInfo();
    }
    /**
     * Remove a connection status listener
     * @param {number} handler
     */

  }, {
    key: 'removeConnectionStatusListener',
    value: function removeConnectionStatusListener(handler) {
      return this.helper.removeConnectionStatusListener(handler);
    }
    /**
     * Set a new authentication methods
     * @param {function():AbstractHandshake} authentication
     */

  }, {
    key: 'setAuthentication',
    value: function setAuthentication(authentication) {
      this.helper.setAuthentication(authentication);
    }
    /**
     * Set logging level
     * Valid values are the strings 'error', 'warn', 'info' and 'debug', from
     * less verbose to more verbose.
     * @param {string} level
     */

  }, {
    key: 'setLogLevel',
    value: function setLogLevel(level) {
      this.helper.setLogLevel(level);
    }
    /**
     * Set new client resource value
     * @param {string} resource
     */

  }, {
    key: 'setResource',
    value: function setResource(resource) {
      this.helper.setResource(resource);
    }
    /**
     * Remove all subscriptions
     * @param {Object} service
     */

  }, {
    key: 'unsubscribe',
    value: function unsubscribe(service) {
      if (!service.$subscriptions) {
        throw new TypeError('Missing $subscriptions property in service');
      }
      return this.helper.unsubscribe(service.$subscriptions);
    }
  }]);

  return Client;
}();

/**
 * Add shorthand connection status method
 */


Object.getOwnPropertyNames(_connectionStatus.ConnectionStatusListener.prototype).forEach(function (method) {
  // Only implements unsupported methods
  if (!Client.prototype.hasOwnProperty(method)) {
    Client.prototype[method] = function addListener(listener) {
      return this.addConnectionStatusListener(_defineProperty({}, method, listener));
    };
  }
});